#Get Started
Когда вы разрабатываете более-менее сложное приложение, у Вас всегда встает вопрос выбора его архитектуры, для того, чтобы во время разработки четко выделить и обособить независимые части вашего приложения; или для внесения изменений в будущем; или для отслеживания происходящих процессов в Вашем приложении во время исправления багов.

> Не имеет значения, как вы спроектировали свое приложение, - с течением времени приложение должно расти и изменяться, иначе оно попросту "погибнет".

И в этих случаях ключевым моментом становится вопрос проектированния архитектуры приложения, а именно - возможности вносить более-менее безболезненные изменения, которые не затрагивают остальные части Вашего приложения, в логику поведения.

Для этого необходимо сначала рассматривать общую структуру Вашего приложения без привязки к какому-либо фреймворку или языку программирования. А потом уже, когда выделены и спроектированы основные моменты, переходить к реализации.

Проектируя `StateFlow`, мы исходили из указанных предпосылок:
- гибкость описания;
- быстрота внесения последующих изменений.

##State
Как правило, любое приложение обладает состояниями, в которых оно может находиться, причем они являются взаимоисключающими, - приложение может находиться только в одном из них. Находясь в одном из этих состояний, Ваше приложение может перейти в другое, **НО** заранее известное состояние.

>Описание приложения с помощью состояний является одним из возможных и распространенных способов, к примеру [state machine](http://en.wikipedia.org/wiki/Finite-state_machine)

Например, Ваше приложение может содержать состояния `login` `home` `search` `details` которые негластно соответствуют экранам Вашего приложения, и между которыми оно переходит по определенным событиям.

Если ввести следующее ограничение: *приложение не может переходить в то состояние, в котором оно нахожится* (то есть из состояния 'A' в состояние 'A', минуя другие состояния), то становится возможным описать любое приложение с помощью [направленного ацикличного графа](http://en.wikipedia.org/wiki/Directed_acyclic_graph):
<a name="pic1"></a>

![Directed acyclic graph](assets/1.png)

В нем в качестве узлов будут находиться состояния Вашего приложения, а стрелочками будут указаны переходы между ними.

И уже Вам решать, как выделять состояния, потому что это могут быть как экраны приложения, так и иные критерии или их множество. Так никто не мешает Вам, к примеру, сопоставить одному экрану приложения несколько состояний.

Главное - чтобы состояния были выделены и обособлены, и Вы могли задать этому состоянию параметры перехода в него.

Во время проектирования вы должны понимать, что:

* состояния приложения являются взаимоисключаемыми: то есть приложение в любую единицу времени может находиться только в одном состоянии;
* при переходе в состояние Вы можете задавать параметры этого перехода.

Кроме этого, хотелось бы, чтобы после перехода в какое-либо состояние у нас была возможность привязать коллбэк-метод на достижение этого состояния. Добавим это как еще одно требование:

Но абстрактное состояние приложения не несет полезных возможностей, поэтому, чтобы полностью описать состояние:
* Вы должны привязать один или несколько коллбэк-методов, которые срабатывают, когда приложение переходит в это состояние;
* для удобства чтения кода состояния должны иметь имена.

В следующем примере Вы можете увидеть описание трех состояний и присоеденение к ним коллбэков; и, собственно, переход в одно из состояний с параметрами:
 
```javascript
// description
state('login').attach(callback)
state('home').attach(callback2).attach(callback3)
state('details').attach(callback4).attach(callback5)
....

// turn on state
state('details').turn({client: 47568})
```
Такая запись уже позволяет нам в будущем, при добавлении какой-либо независимой функциональности для определенного состояния, просто зарегистрировать ее как дополнительный коллбэк.

Реализация указаного функционала несложная и не сильно отличается от стандартных реализаций `event emitter` и `publisher-subscriber`.

Проблемы начинаются дальше, когда начинаем рассматривать процессы, происходящие при переключении между состояниями, и когда приходит понимание того, что там происходят дополнительные процессы, и они тоже влияют на логику поведения. Как правило, параметры перехода в состояние - это не те данные, которые должны, например, отображаться пользователю в новом состоянии. Параметры перехода в состояние должны преобразовываться в данные для следующего состояния.

##Flow

Фактически [в ранее приведенной диаграмме](#pic1) стрелочки представляют собой процессы - и их тоже необходимо описывать.

В связи с тем, что промежуточных состояний в приложении не может быть, и сам процесс перехода может содержать несколько абсолютно независимых операций, самым удобным решением будет описать процессы перехода между состояниями (*стрелочки на диаграмме*) как [транзакции](http://en.wikipedia.org/wiki/Transaction_processing).

Такое свойство, как [атомарность](http://en.wikipedia.org/wiki/Transaction_processing#Atomicity) транзакции (а также и остальные ее свойства) позволяют нам сосредоточиться на каждой операции отдельно и скомпоновать их с помощью [**функционального подхода**](https://en.wikipedia.org/wiki/Functional_programming).

То есть:

* переход между состояниями *при необходимости* может быть описан последовательностью любого количества независимых операций, и эта последовательность является транзакцией. 

И наше описание логики приложения теперь приобретает вид:

```javascript
// description
state('login').attach(callback)
state('home').attach(callback2).attach(callback3)
....

// description 
flow.to('details')
	.process(opeartion1)
	.process(opeartion2)
	.process(opeartion3)
	.described()
	
// turn on state
state('details').turn({client: 47568})

```

Таким образом, когда Вы переключаете состояние приложения на другое, передаваемые в состояние параметры проходят через последовательность независимых операций, которые обрабатывают входные параметры и передают в состояние уже подготовленные данные.

В дальнейшем последовательность независимых операций для перехода из состояния в состояние мы будем называть **транзакциями**.

Кроме этого, в транзакции могут существовать **декоративные операции** - те, которые производят не операции с параметрами, а какой-либо сайд-эффект. К примеру, показывают и скрывают попап с прогрессом скачивания файла или логируют изменение состояния приложений с учетом входных параметров.

В таком виде, связав описанные и выделенные состояния вашего приложения и применив [функциональный подход](https://en.wikipedia.org/wiki/Functional_programming) для описания последовательности операций перехода, становится намного легче отслеживать логику поведения приложения и вносить любые изменения.

##Middleware

Операции в транзакции перехода становятся сходными с объектами **middleware** в [Connect](https://github.com/senchalabs/connect) из node.js, так как они в большинстве своем представляют собой небольшие независимые сервисы, которые предоставляют услуги по обработке входных данных.

К сожалению, реальная логика приложения далека от четкой последовательности операций, поэтому каждая операция обладает еще следующими возможностями:

1. Возможность самостоятельно передать управление и данные следующей операции (**middleware**) в последовательности, так как операции могут быть асинхронными.
2. Возможность передать управление и данные не следующей операции, а обработчику исключительных ситуаций.
3. Возможность переключить состояние приложения, остановив (**оборвав**) текущую транзакцию.

Описание любого **middleware** имеет следующий вид:

```javascript
var middleware = function (data, chain) {
	// your code
	// ...
	
	// and in the end
	// or
	chain.next(newData);
	// or
	chain.error(errorData);
	// or
	chain.swithTo('new_state', newDataForState);
}
``` 

В этом случае, описание, чтение и внесение изменений в логику приложений (потока операций перехода в состояние) становится достаточно легко:

```javascript
// one of possible ways to describe middleware
function showUserScreen(data, chain) {
	//..
	chain.switchTo('permissionScreen', param);
}

// we describe the simplest transition transaction with an option of halt and transition to another state
flow.to('detailsScreen')
    .process(checkUserRole)
    .error(showUserScreen)
    .process(showDetails)
    .described();
    
// when we need to move to the state 'details_screen', we execute:
state('detailsScreen').turn(params);
```
Например, для того, чтобы в будущем добавить показ попапа с лоадером, нужно добавить `.process(showLoader)` как первую операцию последовательности и сказать транзакции, что при любом ее исходе, в том числе прерывании, необходимо скрыть лоадер. `.after(hideLoader)`

> Так как идея **middleware** не исключает произведение сторонних эффектов, становится важным понятие контекста выполнения, в связи с чем мы добавили возможность указания контекста для выполнения операции:
> 
> ```javascript
> .process(checkUserRole, context)
> ```
> Это позволит Вам не только стандартно использовать ссылку на контекст выполнения операции, но и позволит более наглядно (*декларативно*) остслеживать и изменять цели сторонних эффектов, к примеру, хранилища данных:
> 
> ```javascript
> // process of saving data to local storage 
> .process(saveData, localStorage)
> 
> // other case
> // saving to file storage
> .process(saveData, fileStorage)
> ```
> Для такого использования достаточно, чтобы `localStorage` и `fileStorage` имели одинаковое API, а операция `saveData` имела доступ к этому API через контекст выполнения **this**.
> 
> Возможность указания контекста также работает и для `state('name').attach(callback, context)`


##Extensions
С нашей точки зрения, данный подход к *склеиванию* логических операций позволяет быстро писать цепочки с маршрутизацией (переключением состояний и обработкой ошибок), связанные с состояниями приложения. Но что наиболее важно, - он позволяет быстро вносить изменения и модифицировать логику поведения приложения, так как логические связи между частями приложения четко выстроены.

Не хватает только небольшого блеска: возможности запускать переход в опеределенное состояние приложения по событию извне.

Например, так:

```javascript
state('details')
	.DOMEmitter('click', document.querySelector('#home_button'))
	.route('/details/:id')
	.attach(callback);

flow.to('details')
	.process(showLoader)
	.process(checkAuthorize)
	.error(gotoLogin)
	.process(getDataFromserver)
	.after(hideLoader)
	.described();
```
В этом случае, когда Вы переходите по ссылке соответствующий url `/details/:id`, или в том случае, когда Вы нажмете на кнопку `#home_button`, данные с этих событий собираются, и запускается транзакция перехода в состояние `details` с указанными **middleware**: `showLoader`, `checkAuthorize`, `gotoLogin`, `getData`, `hideLoader` и параметрами перехода из события.

Выглядит неплохо, но никто и никогда не знает, какие события необходимо будет отслеживать в Вашем приложении, кто будет эмиттером этого события, и какие данные каким образом нужно будет передать дальше.

Поэтому вместо того, чтобы раз и навсегда ограничить возможности описания только отслеживанием DOM-событий или событий routing'a, мы предлагаем возможность расширения описания с помощью регистрации `custom descriptor`'a, а если быть более точным - с помощью возможности описания нового функции для `state` и ее последующего испоьзования.

Пример:

```javascript
// register processing function via name and function
state.registerFn('emitter', function (event, emitter) {
    emitter.on(event, function (e) {
    	 //	 turn current state with event as parameters
        this.turn(e);
    }.bind(this));
});

state('my_state')
    .emitter('event', eventEmitter) // when event turn on
    .attach(callback); // state callback

// describe flow to 'my_state'
flow.to('my_state')
    .process(middleware)
    .described();

// and then, if you neen start switching to 'my_state' with parameters
eventEmitter.emit('event', {counter: 0});
```

Аналогичным образом Вы можете описать и event emiters для DOM-событий или событий роутинга.

##Summary

Как вы видите, `StateFlow` позволяет описать логику поведения Вашего приложения как набора независимых состояний приложения и транзакций переходов между ними, которые описываются в [функциональном стиле](http://en.wikipedia.org/wiki/Functional_programming).

Фактически `StateFlow` позволяет Вам описывать логику Вашего приложения через обособленые опрерации, то есть использовать подобие [DSL](https://en.wikipedia.org/wiki/Domain-specific_language) в разработке Вашего приложения. 

В результате синтаксис бизнес-логики поведения Вашего приложения получается достаточно лаконичным, читаемым и гибким.

В любой момент Вы можете добавить или изменить любую операцию во время перехода в сотояние Вашего приложения; или добавить или убрать любой коллбэк на переход в состояние.

Мы постарались максимально упростить `StateFlow` и убрали все зависимости, поэтому его можно использовать для описании бизнес-логики практически с любым фреймворком.

>Как нетрудно заметить, у `StateFlow` есть очень много общего с [state machine](http://en.wikipedia.org/wiki/Finite-state_machine), и кроме этого, переключение состояний с входными параметрами и последовательностью операций перехода позволяет его использовать в качестве альтернативы [Flux](https://facebook.github.io/flux/) для работы с [ReactJS](https://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html). Вам необходимо просто согласовать состояния двух стейт-машин.